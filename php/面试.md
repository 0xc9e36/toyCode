### 浏览器访问一个网页过程(www.baidu.com)
[点击参考](https://github.com/skyline75489/what-happens-when-zh_CN/blob/master/README.rst)
* 键盘读入，浏览器解析协议，路径信息；对URL中非ASCII字符进行编码。
* 检查浏览器内置HSTS列表，判断是否使用HTTPS协议。如果没有在列表中，又需要使用HTTPS，服务器会向客户端发送一个响应告知客户端应该使用HTTPS。
* DNS解析：浏览器dns缓存，本地hosts，操作系统缓存(gethostbyname())，如果都没有就向本地DNS服务器查询(UDP协议，53端口)，这一步是递归查询。而本地DNS服务器如果没有查到，就向根DNS服务器查询，
根DNS服务器返回com级域名服务器的IP，本地域名服务器再去查询com DNS服务器，com DNS服务器找到负责baidu.com的DNS服务器，并将IP返回给本地DNS服务器。
* ARP查询
  - 同一网络中：广播
  - 不同网络：经过路由器转发，目的MAC地址设置为路由器网MAC地址，IP地址不变。
* 使用套接字，调用系统库函数 socket，请求TCP流套接字，封装HTTP请求报文,层层封装，物理介质发送。
* 建立连接：请求在TCP第三次握手就发送出去了，浏览器会选择大于1024的端口。
* TLS握手
  - 客户端发送ClientHello报文，包含客户端TLS版本，可用的加密算法，压缩算法。
  - 服务器返回ServerHello报文，包含服务端TLS版本，服务器选择的压缩，加密算法，以及CA签发的数字证书，证书中包含服务端的公钥。
  - 客户端根据自己信任的CA列表去验证服务器证书是否合格，如果可信，客户端生成一串伪随机数，使用服务器公钥加密，用于生成对称密钥。
  - 服务器使用私钥解密，并生成了对称密钥
  - 客户端发送Finished消息给服务端，使用对称密钥加密一个hash。
  - 服务端解密此hash，然后生成自己的hash，如果两个值相同，向客户端发送一个Finished，也使用对称密钥加密。
  - 此后所有通讯内容使用对称密钥加密。
* 路由寻址：每经过一个路由器，TTL减一，当减小到0时还没有到达则丢弃。
* 数据传送
* 释放连接：四次挥手

## HTTP常见状态码
* 1xx：服务器已接收，需要客户端继续执行
* 2xx：成功，操作成功并处理
  - 200：请求完成
* 3xx：重定向，需要进一步操作
  - 301：永久移动
  - 302：临时移动
  - 304：未修改
* 4xx：客户端错误
  - 400：客户端语法错误
  - 401:身份验证未通过
  - 403：禁止访问
  - 404：资源不存在
* 5xx：服务端错误
  - 500：服务器内部错误
  - 501：服务器不支持请求方法
  - 502：代理服务器从远程收到无效的请求
  - 504：代理服务器未及时从远程收到请求
  - 505：HTTP协议版本不支持


### 进程线程区别
* 进程是操作系统资源分配的最小单位，线程是CPU调度的最小单位。
* 进程fork()开销大，地址空间是copy on write，但是会有一个复制父进程页表的过程，所以开销较大，而线程是共享页表的。为什么页表不是COW呢？
* 当进程非常多时，处理器大量时间用于上下文切换，每个进程都是独立的空间，内存消耗极大，父子进程间通信的高IPC也会带来开销。
* 虽然多线程能解决fork()开销问题，但是内存消耗和处理器调度问题任然存在，所以多线程和多进程本质上是一样的。
* 进程间数据共享需要IPC，线程可以共享进程数据。
* 进程健壮性比线程强，进程间相互独立，互不影响；而一个线程挂掉可能会导致整个进程挂掉。

### 进程间通信方式
* 管道：用于单机
  - 有名管道：父子进程
  - 无名管道：不同进程
* 信号量：资源计数器
* 消息队列
* 共享内存
* 套接字

### 线程同步方式
* 读写锁
* 条件变量：当某一条件满足时候，线程A通知另一阻塞在条件变量上的线程B，B满足了条件，解除阻塞。
* 信号量：资源计数器。



### 常见I/O模型
同步/异步是进程与内核之间的交互方式，阻塞/非阻塞是进程调用内核I/O的方式。
* 同步阻塞
* 同步非阻塞
* 事件驱动
Linux下使用select/poll/epoll来实现，epoll_wait() 将进程阻塞住，直到epoll里发生了注册时的事件（fd可读）：
  * listenfd：调用accept()处理
  * 普通fd：加入线程池
     
epoll两种工作模式：
比如有一个fd上有20kb数据，但是线程一次只读了10kb，那么这个线程是可读了，但是设置了ET后就不会再次分配给其他线程。
* 边沿触发ET：只有在状态改变时才通知
* 水平触发LT：只要是这个状态就通知
    
    
浏览器突然关闭 ：fd上会返回一个可读事件，线程read后返回0，代表对方已关闭连接，此时调用close()即可。    
系统突然掉电：协议栈无法感知，依靠应用层timer实现。    
timer实现可采用红黑树，最小堆。    

## Dijkstra算法
用来计算一个节点到其他全部节点的最短路径    
[Dijkstra 算法](https://www.61mon.com/index.php/archives/194/comment-page-2)：这篇文章讲得非常好

## ArrayList与LinkedList区别
ArrayList内部使用数组实现，LinkedList使用双链表实现，可以围绕链表和数组的特性展开。

## B-Tree和B+Tree
[说说B-树，B-树，B-树](http://www.bigming.me/2016/12/28/%E8%AF%B4%E8%AF%B4B-%E6%A0%91%EF%BC%8CB-%E6%A0%91%EF%BC%8CB-%E6%A0%91/)
     
 大规模存储系统中，二叉树深度过大，当内存无法存储所有节点时，需要读取磁盘，进行I/O操作，从而树的深度越大，I/O效率越低。
B-Tree通过多叉的实现来降低树的高度。
每个节点都存放一个指针，指向数据在磁盘中的位置
* 搜索：现在节点内部进行二分查找，未命中则查询子节点。
* 插入：若插入新元素后节点未满，直接插入即可，否向上生长，直至根节点。
* 删除
    
B+Tree
应对文件系统而产生，只有在最底层的叶子节点才保存数据，非叶子节点只保存索引。
所有数据在叶子节点中以链表存放，只需要遍历一次链表就行。    

比较    
数据库索引采用B+树的主要原因是B树在提高了IO性能的同时并没有解决元素遍历效率低下的问题，而也正是为了解决该问题，B+树应运而生。因为叶子节点中增加了一个链指针，B+树只需要取遍历叶子节点可以实现整棵树的遍历。而且数据库中基于范围的查询是非常频繁的，B树对基于范围的查询效率太低












