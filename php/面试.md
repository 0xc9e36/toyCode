### 浏览器访问一个网页过程(www.baidu.com)
[点击参考](https://github.com/skyline75489/what-happens-when-zh_CN/blob/master/README.rst)
* 键盘读入，浏览器解析协议，路径信息；对URL中非ASCII字符进行编码。
* 检查浏览器内置HSTS列表，判断是否使用HTTPS协议。如果没有在列表中，又需要使用HTTPS，服务器会向客户端发送一个响应告知客户端应该使用HTTPS。
* DNS解析：浏览器dns缓存，本地hosts，操作系统缓存(gethostbyname())，如果都没有就向本地DNS服务器查询(UDP协议，53端口)，这一步是递归查询。而本地DNS服务器如果没有查到，就向根DNS服务器查询，
根DNS服务器返回com级域名服务器的IP，本地域名服务器再去查询com DNS服务器，com DNS服务器找到负责baidu.com的DNS服务器，并将IP返回给本地DNS服务器。
* ARP查询
  - 同一网络中：广播
  - 不同网络：经过路由器转发，目的MAC地址设置为路由器网MAC地址，IP地址不变。
* 使用套接字，调用系统库函数 socket，请求TCP流套接字，封装HTTP请求报文,层层封装，物理介质发送。
* 建立连接：请求在TCP第三次握手就发送出去了，浏览器会选择大于1024的端口。
* TLS握手
  - 客户端发送ClientHello报文，包含客户端TLS版本，可用的加密算法，压缩算法。
  - 服务器返回ServerHello报文，包含服务端TLS版本，服务器选择的压缩，加密算法，以及CA签发的数字证书，证书中包含服务端的公钥。
  - 客户端根据自己信任的CA列表去验证服务器证书是否合格，如果可信，客户端生成一串伪随机数，使用服务器公钥加密，用于生成对称密钥。
  - 服务器使用私钥解密，并生成了对称密钥
  - 客户端发送Finished消息给服务端，使用对称密钥加密一个hash。
  - 服务端解密此hash，然后生成自己的hash，如果两个值相同，向客户端发送一个Finished，也使用对称密钥加密。
  - 此后所有通讯内容使用对称密钥加密。
* 路由寻址：每经过一个路由器，TTL减一，当减小到0时还没有到达则丢弃。
* 数据传送
* 释放连接：四次挥手

## HTTP常见状态码
* 1xx：服务器已接收，需要客户端继续执行
* 2xx：成功，操作成功并处理
  - 200：请求完成
* 3xx：重定向，需要进一步操作
  - 301：永久移动
  - 302：临时移动
  - 304：未修改
* 4xx：客户端错误
  - 400：客户端语法错误
  - 401:身份验证未通过
  - 403：禁止访问
  - 404：资源不存在
* 5xx：服务端错误
  - 500：服务器内部错误
  - 501：服务器不支持请求方法
  - 502：代理服务器从远程收到无效的请求
  - 504：代理服务器未及时从远程收到请求
  - 505：HTTP协议版本不支持


### 进程线程区别
* 进程是操作系统资源分配的最小单位，线程是CPU调度的最小单位。
* 进程fork()开销大，地址空间是copy on write，但是会有一个复制父进程页表的过程，所以开销较大，而线程是共享页表的。为什么页表不是COW呢？
* 当进程非常多时，处理器大量时间用于上下文切换，每个进程都是独立的空间，内存消耗极大，父子进程间通信的高IPC也会带来开销。
* 虽然多线程能解决fork()开销问题，但是内存消耗和处理器调度问题任然存在，所以多线程和多进程本质上是一样的。
* 进程间数据共享需要IPC，线程可以共享进程数据。
* 进程健壮性比线程强，进程间相互独立，互不影响；而一个线程挂掉可能会导致整个进程挂掉。

### 进程间通信方式
* 管道：用于单机
  - 有名管道：父子进程
  - 无名管道：不同进程
* 信号量：资源计数器
* 消息队列
* 共享内存
* 套接字

### 线程同步方式
* 读写锁
* 条件变量：当某一条件满足时候，线程A通知另一阻塞在条件变量上的线程B，B满足了条件，解除阻塞。
* 信号量：资源计数器。



### 常见I/O模型
同步/异步是进程与内核之间的交互方式，阻塞/非阻塞是进程调用内核I/O的方式。
* 同步阻塞
* 同步非阻塞
* 事件驱动
Linux下使用select/poll/epoll来实现，epoll_wait() 将进程阻塞住，直到epoll里发生了注册时的事件（fd可读）：
  * listenfd：调用accept()处理
  * 普通fd：加入线程池
     
epoll两种工作模式：
比如有一个fd上有20kb数据，但是线程一次只读了10kb，那么这个线程是可读了，但是设置了ET后就不会再次分配给其他线程。
* 边沿触发ET：只有在状态改变时才通知
* 水平触发LT：只要是这个状态就通知
    
    
浏览器突然关闭 ：fd上会返回一个可读事件，线程read后返回0，代表对方已关闭连接，此时调用close()即可。    
系统突然掉电：协议栈无法感知，依靠应用层timer实现。    
timer实现可采用红黑树，最小堆。    

## epoll实现原理
[epoll实现原理](http://luodw.cc/2016/01/24/epoll/)    
内核初始化epoll时，会开辟一块内核高速cache区域，用来存放我们监听的socket，这些socket以红黑树的形式保存在内核中，同时建立一个链表，用来存储就绪事件，所以调用epoll_wait()时候，在timeout时间内，查找链表是否有数据，等到超时时间到了后，如果链表没数据，直接返回；如果有数据，拷贝到用户态events数组中。    
调用epoll_ctl()时，除了把socket放到epoll文件系统里file对象对应的红黑树上面之外，还会给内核中断处理程序注册一个回调函数，用来通知内核把它放到就绪链表里面去，所以当一个socket上面有数据到了的时候，内核把网卡上的数据copy到内核中然后把socket插入到就绪链表里面。    

ET和LT：调用epoll_wait()时候，会把就绪的socket拷贝到用户态内存，然后情况就绪链表，最后epoll_wait()检查这些socket，如果是LT，并且这些socket上还有未处理的事件，又把该句柄重新放到就绪链表中去。    

epoll/select对比：    
1.select/poll监听的文件描述符受限，select只能是2048个，epoll不受限制，它支持的上限是最大打开文件的数目。    
2.select/poll需要循环检测所有fd是否就绪，当fd上百万或更多时候，非常耗时，而epoll只处理就绪fd。

       


## Dijkstra算法
用来计算一个节点到其他全部节点的最短路径    
[Dijkstra 算法](https://www.61mon.com/index.php/archives/194/comment-page-2)：这篇文章讲得非常好

## ArrayList与LinkedList区别
ArrayList内部使用数组实现，LinkedList使用双链表实现，可以围绕链表和数组的特性展开。

## B-Tree和B+Tree
[说说B-树，B-树，B-树](http://www.bigming.me/2016/12/28/%E8%AF%B4%E8%AF%B4B-%E6%A0%91%EF%BC%8CB-%E6%A0%91%EF%BC%8CB-%E6%A0%91/)
     
 大规模存储系统中，二叉树深度过大，当内存无法存储所有节点时，需要读取磁盘，进行I/O操作，从而树的深度越大，I/O效率越低。
B-Tree通过多叉的实现来降低树的高度。
每个节点都存放一个指针，指向数据在磁盘中的位置
* 搜索：现在节点内部进行二分查找，未命中则查询子节点。
* 插入：若插入新元素后节点未满，直接插入即可，否向上生长，直至根节点。
* 删除
    
B+Tree
应对文件系统而产生，只有在最底层的叶子节点才保存数据，非叶子节点只保存索引。
所有数据在叶子节点中以链表存放，只需要遍历一次链表就行。    

比较    
数据库索引采用B+树的主要原因是B树在提高了IO性能的同时并没有解决元素遍历效率低下的问题，而也正是为了解决该问题，B+树应运而生。因为叶子节点中增加了一个链指针，B+树只需要取遍历叶子节点可以实现整棵树的遍历。而且数据库中基于范围的查询是非常频繁的，B树对基于范围的查询效率太低

## 一致性hash
解决分布式系统中数据迁移问题。    
[参考](http://blog.csdn.net/cywosp/article/details/23397179)


## TCP建立连接以及释放释放
* 三次握手
  - 初始序列号ISN，不能硬编码
  - 协商MSS
  - 半连接队列
  - 满连接队列(accept())
  - 第二次握手后客户端掉线，Linux下服务端默认会重发5次后断开连接（1 2 4 16 32）。
* 四次挥手
  - 半连接检测：设置保活计数器， 到期则发送探测报文，如果没回应，连续发10个关闭连接，也可能客户端奔溃重启，会发来RST报文。
  - SYN洪泛攻击
  - TIME_WAIT数量太多：主动断开连接导致
  
## 可靠传输实现
* 防丢失：带重传的肯定确认，定时器机制。
* 防止重复和乱序：编号
* 确认机制的特点：
  - 确认指明希望收到下一个的序号
  - 累计确认
  - 捎带确认
* 超时重传定时器
  - Jacobson 算法：针对正常情况，只有一次重传。
  - Karn 算法：避免确认的二义性，重传时间成倍递增，达到一定次数则断开连接；如果下一次数据未发生重传，则恢复Jacobson算法。
  
* 滑动窗口机制     
TCP窗口大小为字节数，最大为65565字节    
坚持定时器：一个确认仅包含非0通告窗口，如果丢失了，那么为了避免双方互相等待发生死锁，发送方使用坚持定时器发送查询报文，采用指数退避算法，最后每隔60秒发送一次。      
* 糊涂窗口综合征
  - 接收方：等缓冲区可用空间达到MSS或总空间的一般再发送新的窗口通告，此外在窗口大小不足时也可以推迟发送确认（最多500ms）。
  - 发送方：Nagle算法： 1.数据大小>=MSS或者对方可用窗口>=MSS才发送； 2.含有FIN允许发送；3.收到对方ack可发送。
* 快重传：发送方发送了1 2 3 4 5份数据，接收方收到了1，马上回ack 2，但是网络中2丢了，这时3来了，还是回ack 2，后面的4 5 都到了，仍然回ack 2，因为2还没有收到，发送方一连收到三个ack=2的确认，就会重传2，接收端收到2以后，因为此时3 4 5都到了，所以回ack 6.

## 拥塞控制
* 慢开始，拥塞避免
* 快重传，快恢复







